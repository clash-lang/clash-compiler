- BlackBox:
    name: GHC.Prim.quotRemInt#
    kind: Declaration
    type: 'quotRemInt# ::
      Int# -> Int# -> (#Int#, Int##)'
    template: |-
      // quotRemInt begin
      ~SIGD[~GENSYM[quot_res][0]][0];
      ~SIGD[~GENSYM[rem_res][1]][0];
      assign ~SYM[0] = ~ARG[0] / ~ARG[1];
      assign ~SYM[1] = ~ARG[0] % ~ARG[1];

      assign ~RESULT = {~SYM[0],~SYM[1]};
      // quotRemInt end
- BlackBox:
    name: GHC.Prim.quotRemWord#
    kind: Declaration
    type: 'quotRemWord# ::
      Word# -> Word# -> (#Word#, Word##)'
    template: |-
      // quotRemWord begin
      ~SIGD[~GENSYM[quot_res][0]][0];
      ~SIGD[~GENSYM[rem_res][1]][0];
      assign ~SYM[0] = ~ARG[0] / ~ARG[1];
      assign ~SYM[1] = ~ARG[0] % ~ARG[1];

      assign ~RESULT = {~SYM[0],~SYM[1]};
      // quotRemWord end
- BlackBox:
    name: GHC.Prim.popCnt8#
    imports:
    - ~INCLUDENAME[0].inc
    includes:
    - name: depth2Index
      extension: inc
      template: |-
        // given a level and a depth, calculate the corresponding index into the
        // intermediate array
        function integer ~INCLUDENAME[0];
          input integer levels;
          input integer depth;

          ~INCLUDENAME[0] = (2 ** levels) - (2 ** depth);
        endfunction
    kind: Declaration
    type: 'popCnt8# :: Word#
      -> Word#'
    template: |-
      // popCnt8 begin
      localparam ~GENSYM[width][0] = 8;

      // depth of the tree
      localparam ~GENSYM[levels][2] = $clog2(~SYM[0]);

      logic [~SYM[2]:0] ~GENSYM[intermediate][3] [0:(2*~SYM[0])-2];

      // put input into the first half of the intermediate array
      genvar ~GENSYM[i][4];
      ~GENERATE
      for (~SYM[4] = 0; ~SYM[4] < ~SYM[0]; ~SYM[4]=~SYM[4]+1) begin : ~GENSYM[mk_array][11]
        assign ~SYM[3][~SYM[4]] = $unsigned(~VAR[input][0][~SYM[4]]);
      end
      ~ENDGENERATE

      // Create the tree of instantiated components
      genvar ~GENSYM[d][6];
      genvar ~GENSYM[i][7];
      ~GENERATE
      if (~SYM[2] != 0) begin : ~GENSYM[make_tree][8]
        for (~SYM[6] = ~SYM[2]; ~SYM[6] > 0; ~SYM[6]=~SYM[6]-1) begin : ~GENSYM[tree_depth][9]
          for (~SYM[7] = 0; ~SYM[7] < (2**(~SYM[6]-1)); ~SYM[7] = ~SYM[7]+1) begin : ~GENSYM[tree_depth_loop][10]
            assign ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6])+~SYM[7]] =
                   ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+1)+(2*~SYM[7])] +
                   ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+1)+(2*~SYM[7])+1];
          end
        end
      end
      ~ENDGENERATE

      // The last element of the intermediate array holds the result
      assign ~RESULT = $unsigned(~SYM[3][(2*~SYM[0])-2]);
      // popCnt8 end
- BlackBox:
    name: GHC.Prim.popCnt16#
    imports:
    - ~INCLUDENAME[0].inc
    includes:
    - name: depth2Index
      extension: inc
      template: |-
        // given a level and a depth, calculate the corresponding index into the
        // intermediate array
        function integer ~INCLUDENAME[0];
          input integer levels;
          input integer depth;

          ~INCLUDENAME[0] = (2 ** levels) - (2 ** depth);
        endfunction
    kind: Declaration
    type: 'popCnt16# :: Word#
      -> Word#'
    template: |-
      // popCnt16 begin
      localparam ~GENSYM[width][0] = 16;

      // depth of the tree
      localparam ~GENSYM[levels][2] = $clog2(~SYM[0]);

      logic [~SYM[2]:0] ~GENSYM[intermediate][3] [0:(2*~SYM[0])-2];

      // put input into the first half of the intermediate array
      genvar ~GENSYM[i][4];
      ~GENERATE
      for (~SYM[4] = 0; ~SYM[4] < ~SYM[0]; ~SYM[4]=~SYM[4]+1) begin : ~GENSYM[mk_array][11]
        assign ~SYM[3][~SYM[4]] = $unsigned(~VAR[input][0][~SYM[4]]);
      end
      ~ENDGENERATE

      // Create the tree of instantiated components
      genvar ~GENSYM[d][6];
      genvar ~GENSYM[i][7];
      ~GENERATE
      if (~SYM[2] != 0) begin : ~GENSYM[make_tree][8]
        for (~SYM[6] = ~SYM[2]; ~SYM[6] > 0; ~SYM[6]=~SYM[6]-1) begin : ~GENSYM[tree_depth][9]
          for (~SYM[7] = 0; ~SYM[7] < (2**(~SYM[6]-1)); ~SYM[7] = ~SYM[7]+1) begin : ~GENSYM[tree_depth_loop][10]
            assign ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6])+~SYM[7]] =
                   ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+1)+(2*~SYM[7])] +
                   ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+1)+(2*~SYM[7])+1];
          end
        end
      end
      ~ENDGENERATE

      // The last element of the intermediate array holds the result
      assign ~RESULT = $unsigned(~SYM[3][(2*~SYM[0])-2]);
      // popCnt16 end
- BlackBox:
    name: GHC.Prim.popCnt32#
    imports:
    - ~INCLUDENAME[0].inc
    includes:
    - name: depth2Index
      extension: inc
      template: |-
        // given a level and a depth, calculate the corresponding index into the
        // intermediate array
        function integer ~INCLUDENAME[0];
          input integer levels;
          input integer depth;

          ~INCLUDENAME[0] = (2 ** levels) - (2 ** depth);
        endfunction
    kind: Declaration
    type: 'popCnt32# :: Word#
      -> Word#'
    template: |-
      // popCnt32 begin
      localparam ~GENSYM[width][0] = 32;

      // depth of the tree
      localparam ~GENSYM[levels][2] = $clog2(~SYM[0]);

      logic [~SYM[2]:0] ~GENSYM[intermediate][3] [0:(2*~SYM[0])-2];

      // put input into the first half of the intermediate array
      genvar ~GENSYM[i][4];
      ~GENERATE
      for (~SYM[4] = 0; ~SYM[4] < ~SYM[0]; ~SYM[4]=~SYM[4]+1) begin : ~GENSYM[mk_array][11]
        assign ~SYM[3][~SYM[4]] = $unsigned(~VAR[input][0][~SYM[4]]);
      end
      ~ENDGENERATE

      // Create the tree of instantiated components
      genvar ~GENSYM[d][6];
      genvar ~GENSYM[i][7];
      ~GENERATE
      if (~SYM[2] != 0) begin : ~GENSYM[make_tree][8]
        for (~SYM[6] = ~SYM[2]; ~SYM[6] > 0; ~SYM[6]=~SYM[6]-1) begin : ~GENSYM[tree_depth][9]
          for (~SYM[7] = 0; ~SYM[7] < (2**(~SYM[6]-1)); ~SYM[7] = ~SYM[7]+1) begin : ~GENSYM[tree_depth_loop][10]
            assign ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6])+~SYM[7]] =
                   ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+1)+(2*~SYM[7])] +
                   ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+1)+(2*~SYM[7])+1];
          end
        end
      end
      ~ENDGENERATE

      // The last element of the intermediate array holds the result
      assign ~RESULT = $unsigned(~SYM[3][(2*~SYM[0])-2]);
      // popCnt32 end
- BlackBox:
    name: GHC.Prim.popCnt64#
    imports:
    - ~INCLUDENAME[0].inc
    includes:
    - name: depth2Index
      extension: inc
      template: |-
        // given a level and a depth, calculate the corresponding index into the
        // intermediate array
        function integer ~INCLUDENAME[0];
          input integer levels;
          input integer depth;

          ~INCLUDENAME[0] = (2 ** levels) - (2 ** depth);
        endfunction
    kind: Declaration
    type: 'popCnt64# :: Word#
      -> Word#'
    template: |-
      // popCnt64 begin
      localparam ~GENSYM[width][0] = 64;

      // depth of the tree
      localparam ~GENSYM[levels][2] = $clog2(~SYM[0]);

      logic [~SYM[2]:0] ~GENSYM[intermediate][3] [0:(2*~SYM[0])-2];

      // put input into the first half of the intermediate array
      genvar ~GENSYM[i][4];
      ~GENERATE
      for (~SYM[4] = 0; ~SYM[4] < ~SYM[0]; ~SYM[4]=~SYM[4]+1) begin : ~GENSYM[mk_array][11]
        assign ~SYM[3][~SYM[4]] = $unsigned(~VAR[input][0][~SYM[4]]);
      end
      ~ENDGENERATE

      // Create the tree of instantiated components
      genvar ~GENSYM[d][6];
      genvar ~GENSYM[i][7];
      ~GENERATE
      if (~SYM[2] != 0) begin : ~GENSYM[make_tree][8]
        for (~SYM[6] = ~SYM[2]; ~SYM[6] > 0; ~SYM[6]=~SYM[6]-1) begin : ~GENSYM[tree_depth][9]
          for (~SYM[7] = 0; ~SYM[7] < (2**(~SYM[6]-1)); ~SYM[7] = ~SYM[7]+1) begin : ~GENSYM[tree_depth_loop][10]
            assign ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6])+~SYM[7]] =
                   ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+1)+(2*~SYM[7])] +
                   ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+1)+(2*~SYM[7])+1];
          end
        end
      end
      ~ENDGENERATE

      // The last element of the intermediate array holds the result
      assign ~RESULT = $unsigned(~SYM[3][(2*~SYM[0])-2]);
      // popCnt64 end
- BlackBox:
    name: GHC.Prim.popCnt#
    imports:
    - ~INCLUDENAME[0].inc
    includes:
    - name: depth2Index
      extension: inc
      template: |-
        // given a level and a depth, calculate the corresponding index into the
        // intermediate array
        function integer ~INCLUDENAME[0];
          input integer levels;
          input integer depth;

          ~INCLUDENAME[0] = (2 ** levels) - (2 ** depth);
        endfunction
    kind: Declaration
    type: 'popCnt# :: Word#
      -> Word#'
    template: |-
      // popCnt begin
      localparam ~GENSYM[width][0] = ~SIZE[~TYPO];

      // depth of the tree
      localparam ~GENSYM[levels][2] = $clog2(~SYM[0]);

      logic [~SYM[2]:0] ~GENSYM[intermediate][3] [0:(2*~SYM[0])-2];

      // put input into the first half of the intermediate array
      genvar ~GENSYM[i][4];
      ~GENERATE
      for (~SYM[4] = 0; ~SYM[4] < ~SYM[0]; ~SYM[4]=~SYM[4]+1) begin : ~GENSYM[mk_array][11]
        assign ~SYM[3][~SYM[4]] = $unsigned(~VAR[input][0][~SYM[4]]);
      end
      ~ENDGENERATE

      // Create the tree of instantiated components
      genvar ~GENSYM[d][6];
      genvar ~GENSYM[i][7];
      ~GENERATE
      if (~SYM[2] != 0) begin : ~GENSYM[make_tree][8]
        for (~SYM[6] = ~SYM[2]; ~SYM[6] > 0; ~SYM[6]=~SYM[6]-1) begin : ~GENSYM[tree_depth][9]
          for (~SYM[7] = 0; ~SYM[7] < (2**(~SYM[6]-1)); ~SYM[7] = ~SYM[7]+1) begin : ~GENSYM[tree_depth_loop][10]
            assign ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6])+~SYM[7]] =
                   ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+1)+(2*~SYM[7])] +
                   ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+1)+(2*~SYM[7])+1];
          end
        end
      end
      ~ENDGENERATE

      // The last element of the intermediate array holds the result
      assign ~RESULT = $unsigned(~SYM[3][(2*~SYM[0])-2]);
      // popCnt end
- BlackBox:
    name: GHC.Prim.clz8#
    imports:
    - ~INCLUDENAME[0].inc
    includes:
    - name: enc
      extension: inc
      template: |-
        function [1:0] ~INCLUDENAME[0];
          input [1:0] a;
          case (a)
            2'b00:   ~INCLUDENAME[0] = 2'b10;
            2'b01:   ~INCLUDENAME[0] = 2'b01;
            2'b10:   ~INCLUDENAME[0] = 2'b00;
            default: ~INCLUDENAME[0] = 2'b00;
          endcase
        endfunction
    kind: Declaration
    type: 'clz8 :: Word# ->
      Word#'
    template: |-
      // clz8 begin
      logic [0:7] ~GENSYM[v][1];
      assign ~SYM[1] = ~VAR[i][0][7:0];

      logic [0:7] ~GENSYM[e][2];
      genvar ~GENSYM[n][3];
      ~GENERATE
      for (~SYM[3]=0;~SYM[3]<4;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
        assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
      end
      ~ENDGENERATE

      logic [0:5] ~GENSYM[a][4];
      genvar ~GENSYM[i1][5];
      ~GENERATE
      for (~SYM[5]=0;~SYM[5]<2;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage1][6]
        localparam n = 2;
        logic [3:0] i;
        assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:3] ~GENSYM[res][7];
      ~GENERATE
      if (1) begin
      localparam n = 3;
      logic [5:0] i;
      assign i = ~SYM[4][0:5];
      always_comb begin
        case (i[n-1+n])
          1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
          default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
        endcase
      end
      end
      ~ENDGENERATE

      assign ~RESULT = $unsigned(~SYM[7]);
      // clz8 end
- BlackBox:
    name: GHC.Prim.clz16#
    imports:
    - ~INCLUDENAME[0].inc
    includes:
    - name: enc
      extension: inc
      template: |-
        function [1:0] ~INCLUDENAME[0];
          input [1:0] a;
          case (a)
            2'b00:   ~INCLUDENAME[0] = 2'b10;
            2'b01:   ~INCLUDENAME[0] = 2'b01;
            2'b10:   ~INCLUDENAME[0] = 2'b00;
            default: ~INCLUDENAME[0] = 2'b00;
          endcase
        endfunction
    kind: Declaration
    type: 'clz16 :: Word#
      -> Word#'
    template: |-
      // clz16 begin
      logic [0:15] ~GENSYM[v][1];
      assign ~SYM[1] = ~VAR[i][0][15:0];

      logic [0:15] ~GENSYM[e][2];
      genvar ~GENSYM[i][3];
      ~GENERATE
      for (~SYM[3]=0;~SYM[3]<8;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
        assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
      end
      ~ENDGENERATE

      logic [0:11] ~GENSYM[a][4];
      genvar ~GENSYM[i1][5];
      ~GENERATE
      for (~SYM[5]=0;~SYM[5]<4;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
        localparam n = 2;
        logic [3:0] i;
        assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:7] ~GENSYM[b][9];
      genvar ~GENSYM[i2][10];
      ~GENERATE
      for (~SYM[10]=0;~SYM[10]<2;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
        localparam n = 3;
        logic [5:0] i;
        assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:4] ~GENSYM[res][7];
      ~GENERATE
      if (1) begin
      localparam n = 4;
      logic [7:0] i;
      assign i = ~SYM[9][0:7];
      always_comb begin
        case (i[n-1+n])
          1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
          default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
        endcase
      end
      end
      ~ENDGENERATE

      assign ~RESULT = $unsigned(~SYM[7]);
      // clz16 end
- BlackBox:
    name: GHC.Prim.clz32#
    imports:
    - ~INCLUDENAME[0].inc
    includes:
    - name: enc
      extension: inc
      template: |-
        function [1:0] ~INCLUDENAME[0];
          input [1:0] a;
          case (a)
            2'b00:   ~INCLUDENAME[0] = 2'b10;
            2'b01:   ~INCLUDENAME[0] = 2'b01;
            2'b10:   ~INCLUDENAME[0] = 2'b00;
            default: ~INCLUDENAME[0] = 2'b00;
          endcase
        endfunction
    kind: Declaration
    type: 'clz32 :: Word#
      -> Word#'
    template: |-
      // clz32 begin
      logic [0:31] ~GENSYM[v][1];
      assign ~SYM[1] = ~VAR[i][0][31:0];

      logic [0:31] ~GENSYM[e][2];
      genvar ~GENSYM[i][3];
      ~GENERATE
      for (~SYM[3]=0;~SYM[3]<16;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
        assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
      end
      ~ENDGENERATE

      logic [0:23] ~GENSYM[a][4];
      genvar ~GENSYM[i1][5];
      ~GENERATE
      for (~SYM[5]=0;~SYM[5]<8;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
        localparam n = 2;
        logic [3:0] i;
        assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:15] ~GENSYM[b][9];
      genvar ~GENSYM[i2][10];
      ~GENERATE
      for (~SYM[10]=0;~SYM[10]<4;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
        localparam n = 3;
        logic [5:0] i;
        assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:9] ~GENSYM[c][12];
      genvar ~GENSYM[i3][13];
      ~GENERATE
      for (~SYM[13]=0;~SYM[13]<2;~SYM[13]=~SYM[13]+1) begin : ~GENSYM[mux_stage3][14]
        localparam n = 4;
        logic [7:0] i;
        assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:5] ~GENSYM[res][7];
      ~GENERATE
      if (1) begin
      localparam n = 5;
      logic [9:0] i;
      assign i = ~SYM[12][0:9];
      always_comb begin
        case (i[n-1+n])
          1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
          default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
        endcase
      end
      end
      ~ENDGENERATE

      assign ~RESULT = $unsigned(~SYM[7]);
      // clz32 end
- BlackBox:
    name: GHC.Prim.clz64#
    imports:
    - ~INCLUDENAME[0].inc
    includes:
    - name: enc
      extension: inc
      template: |-
        function [1:0] ~INCLUDENAME[0];
          input [1:0] a;
          case (a)
            2'b00:   ~INCLUDENAME[0] = 2'b10;
            2'b01:   ~INCLUDENAME[0] = 2'b01;
            2'b10:   ~INCLUDENAME[0] = 2'b00;
            default: ~INCLUDENAME[0] = 2'b00;
          endcase
        endfunction
    kind: Declaration
    type: 'clz64 :: Word#
      -> Word#'
    template: |-
      // clz64 begin
      logic [0:63] ~GENSYM[v][1];
      assign ~SYM[1] = ~VAR[i][0][63:0];

      logic [0:63] ~GENSYM[e][2];
      genvar ~GENSYM[i][3];
      ~GENERATE
      for (~SYM[3]=0;~SYM[3]<32;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
        assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
      end
      ~ENDGENERATE

      logic [0:47] ~GENSYM[a][4];
      genvar ~GENSYM[i1][5];
      ~GENERATE
      for (~SYM[5]=0;~SYM[5]<16;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
        localparam n = 2;
        logic [3:0] i;
        assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:31] ~GENSYM[b][9];
      genvar ~GENSYM[i2][10];
      ~GENERATE
      for (~SYM[10]=0;~SYM[10]<8;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
        localparam n = 3;
        logic [5:0] i;
        assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:19] ~GENSYM[c][12];
      genvar ~GENSYM[i3][13];
      ~GENERATE
      for (~SYM[13]=0;~SYM[13]<4;~SYM[13]=~SYM[13]+1) begin : ~GENSYM[mux_stage3][14]
        localparam n = 4;
        logic [7:0] i;
        assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:11] ~GENSYM[d][15];
      genvar ~GENSYM[i4][16];
      ~GENERATE
      for (~SYM[16]=0;~SYM[16]<2;~SYM[16]=~SYM[16]+1) begin : ~GENSYM[mux_stage4][17]
        localparam n = 5;
        logic [9:0] i;
        assign i = ~SYM[12][~SYM[16]*10:~SYM[16]*10+9];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:6] ~GENSYM[res][7];
      ~GENERATE
      if (1) begin
      localparam n = 6;
      logic [11:0] i;
      assign i = ~SYM[15][0:11];
      always_comb begin
        case (i[n-1+n])
          1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
          default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
        endcase
      end
      end
      ~ENDGENERATE

      assign ~RESULT = $unsigned(~SYM[7]);
      // clz64 end
- BlackBox:
    name: GHC.Prim.clz#
    imports:
    - ~INCLUDENAME[0].inc
    includes:
    - name: enc
      extension: inc
      template: |-
        function [1:0] ~INCLUDENAME[0];
          input [1:0] a;
          case (a)
            2'b00:   ~INCLUDENAME[0] = 2'b10;
            2'b01:   ~INCLUDENAME[0] = 2'b01;
            2'b10:   ~INCLUDENAME[0] = 2'b00;
            default: ~INCLUDENAME[0] = 2'b00;
          endcase
        endfunction
    kind: Declaration
    type: 'clz :: Word# ->
      Word#'
    template: |-
      // clz begin
      ~IF ~IW64 ~THEN
      logic [0:63] ~GENSYM[v][1];
      assign ~SYM[1] = ~VAR[i][0][63:0];

      logic [0:63] ~GENSYM[e][2];
      genvar ~GENSYM[i][3];
      ~GENERATE
      for (~SYM[3]=0;~SYM[3]<32;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
        assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
      end
      ~ENDGENERATE

      logic [0:47] ~GENSYM[a][4];
      genvar ~GENSYM[i1][5];
      ~GENERATE
      for (~SYM[5]=0;~SYM[5]<16;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
        localparam n = 2;
        logic [3:0] i;
        assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:31] ~GENSYM[b][9];
      genvar ~GENSYM[i2][10];
      ~GENERATE
      for (~SYM[10]=0;~SYM[10]<8;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
        localparam n = 3;
        logic [5:0] i;
        assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:19] ~GENSYM[c][12];
      genvar ~GENSYM[i3][13];
      ~GENERATE
      for (~SYM[13]=0;~SYM[13]<4;~SYM[13]=~SYM[13]+1) begin : ~GENSYM[mux_stage3][14]
        localparam n = 4;
        logic [7:0] i;
        assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:11] ~GENSYM[d][15];
      genvar ~GENSYM[i4][16];
      ~GENERATE
      for (~SYM[16]=0;~SYM[16]<2;~SYM[16]=~SYM[16]+1) begin : ~GENSYM[mux_stage4][17]
        localparam n = 5;
        logic [9:0] i;
        assign i = ~SYM[12][~SYM[16]*10:~SYM[16]*10+9];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:6] ~GENSYM[res][7];
      ~GENERATE
      if (1) begin
      localparam n = 6;
      logic [11:0] i;
      assign i = ~SYM[15][0:11];
      always_comb begin
        case (i[n-1+n])
          1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
          default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
        endcase
      end
      end
      ~ENDGENERATE
      ~ELSE
      logic [0:31] ~SYM[1];
      assign ~SYM[1] = ~VAR[i][0][31:0];

      logic [0:31] ~SYM[2];
      genvar ~SYM[3];
      ~GENERATE
      for (~SYM[3]=0;~SYM[3]<16;~SYM[3]=~SYM[3]+1) begin : ~SYM[8]
        assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
      end
      ~ENDGENERATE

      logic [0:23] ~SYM[4];
      genvar ~SYM[5];
      ~GENERATE
      for (~SYM[5]=0;~SYM[5]<8;~SYM[5]=~SYM[5]+1) begin : ~SYM[6]
        localparam n = 2;
        logic [3:0] i;
        assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:15] ~SYM[9];
      genvar ~SYM[10];
      ~GENERATE
      for (~SYM[10]=0;~SYM[10]<4;~SYM[10]=~SYM[10]+1) begin : ~SYM[11]
        localparam n = 3;
        logic [5:0] i;
        assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:9] ~SYM[12];
      genvar ~SYM[13];
      ~GENERATE
      for (~SYM[13]=0;~SYM[13]<2;~SYM[13]=~SYM[13]+1) begin : ~SYM[14]
        localparam n = 4;
        logic [7:0] i;
        assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:5] ~SYM[7];
      ~GENERATE
      if (1) begin
      localparam n = 5;
      logic [9:0] i;
      assign i = ~SYM[12][0:9];
      always_comb begin
        case (i[n-1+n])
          1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
          default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
        endcase
      end
      end
      ~ENDGENERATE
      ~FI
      assign ~RESULT = $unsigned(~SYM[7]);
      // clz end
- BlackBox:
    name: GHC.Prim.ctz8#
    imports:
    - ~INCLUDENAME[0].inc
    includes:
    - name: enc
      extension: inc
      template: |-
        function [1:0] ~INCLUDENAME[0];
          input [1:0] a;
          case (a)
            2'b00:   ~INCLUDENAME[0] = 2'b10;
            2'b01:   ~INCLUDENAME[0] = 2'b01;
            2'b10:   ~INCLUDENAME[0] = 2'b00;
            default: ~INCLUDENAME[0] = 2'b00;
          endcase
        endfunction
    kind: Declaration
    type: 'ctz8 :: Word# ->
      Word#'
    template: |-
      // ctz8 begin
      logic [0:7] ~GENSYM[v][1];
      genvar ~GENSYM[k][18];
      ~GENERATE
      for (~SYM[18]=0;~SYM[18]<8;~SYM[18]=~SYM[18]+1) begin : ~GENSYM[reverse][19]
        assign ~SYM[1][~SYM[18]] = ~VAR[][0][~SYM[18]];
      end
      ~ENDGENERATE

      logic [0:7] ~GENSYM[e][2];
      genvar ~GENSYM[i][3];
      ~GENERATE
      for (~SYM[3]=0;~SYM[3]<4;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
        assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
      end
      ~ENDGENERATE

      logic [0:5] ~GENSYM[a][4];
      genvar ~GENSYM[i1][5];
      ~GENERATE
      for (~SYM[5]=0;~SYM[5]<2;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
        localparam n = 2;
        logic [3:0] i;
        assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:3] ~GENSYM[res][7];
      ~GENERATE
      if (1) begin
      localparam n = 3;
      logic [5:0] i;
      assign i = ~SYM[4][0:5];
      always_comb begin
        case (i[n-1+n])
          1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
          default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
        endcase
      end
      end
      ~ENDGENERATE

      assign ~RESULT = $unsigned(~SYM[7]);
      // ctz8 end
- BlackBox:
    name: GHC.Prim.ctz16#
    imports:
    - ~INCLUDENAME[0].inc
    includes:
    - name: enc
      extension: inc
      template: |-
        function [1:0] ~INCLUDENAME[0];
          input [1:0] a;
          case (a)
            2'b00:   ~INCLUDENAME[0] = 2'b10;
            2'b01:   ~INCLUDENAME[0] = 2'b01;
            2'b10:   ~INCLUDENAME[0] = 2'b00;
            default: ~INCLUDENAME[0] = 2'b00;
          endcase
        endfunction
    kind: Declaration
    type: 'ctz16 :: Word#
      -> Word#'
    template: |-
      // ctz16 begin
      logic [0:15] ~GENSYM[v][1];
      genvar ~GENSYM[k][18];
      ~GENERATE
      for (~SYM[18]=0;~SYM[18]<16;~SYM[18]=~SYM[18]+1) begin : ~GENSYM[reverse][19]
        assign ~SYM[1][~SYM[18]] = ~VAR[][0][~SYM[18]];
      end
      ~ENDGENERATE

      logic [0:15] ~GENSYM[e][2];
      genvar ~GENSYM[i][3];
      ~GENERATE
      for (~SYM[3]=0;~SYM[3]<8;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
        assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
      end
      ~ENDGENERATE

      logic [0:11] ~GENSYM[a][4];
      genvar ~GENSYM[i1][5];
      ~GENERATE
      for (~SYM[5]=0;~SYM[5]<4;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
        localparam n = 2;
        logic [3:0] i;
        assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:7] ~GENSYM[b][9];
      genvar ~GENSYM[i2][10];
      ~GENERATE
      for (~SYM[10]=0;~SYM[10]<2;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
        localparam n = 3;
        logic [5:0] i;
        assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:4] ~GENSYM[res][7];
      ~GENERATE
      if (1) begin
      localparam n = 4;
      logic [7:0] i;
      assign i = ~SYM[9][0:7];
      always_comb begin
        case (i[n-1+n])
          1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
          default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
        endcase
      end
      end
      ~ENDGENERATE

      assign ~RESULT = $unsigned(~SYM[7]);
      // ctz16 end
- BlackBox:
    name: GHC.Prim.ctz32#
    imports:
    - ~INCLUDENAME[0].inc
    includes:
    - name: enc
      extension: inc
      template: |-
        function [1:0] ~INCLUDENAME[0];
          input [1:0] a;
          case (a)
            2'b00:   ~INCLUDENAME[0] = 2'b10;
            2'b01:   ~INCLUDENAME[0] = 2'b01;
            2'b10:   ~INCLUDENAME[0] = 2'b00;
            default: ~INCLUDENAME[0] = 2'b00;
          endcase
        endfunction
    kind: Declaration
    type: 'ctz32 :: Word#
      -> Word#'
    template: |-
      // ctz32 begin
      logic [0:31] ~GENSYM[v][1];
      genvar ~GENSYM[k][18];
      ~GENERATE
      for (~SYM[18]=0;~SYM[18]<32;~SYM[18]=~SYM[18]+1) begin : ~GENSYM[reverse][19]
        assign ~SYM[1][~SYM[18]] = ~VAR[][0][~SYM[18]];
      end
      ~ENDGENERATE

      logic [0:31] ~GENSYM[e][2];
      genvar ~GENSYM[i][3];
      ~GENERATE
      for (~SYM[3]=0;~SYM[3]<16;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
        assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
      end
      ~ENDGENERATE

      logic [0:23] ~GENSYM[a][4];
      genvar ~GENSYM[i1][5];
      ~GENERATE
      for (~SYM[5]=0;~SYM[5]<8;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
        localparam n = 2;
        logic [3:0] i;
        assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:15] ~GENSYM[b][9];
      genvar ~GENSYM[i2][10];
      ~GENERATE
      for (~SYM[10]=0;~SYM[10]<4;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
        localparam n = 3;
        logic [5:0] i;
        assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:9] ~GENSYM[c][12];
      genvar ~GENSYM[i3][13];
      ~GENERATE
      for (~SYM[13]=0;~SYM[13]<2;~SYM[13]=~SYM[13]+1) begin : ~GENSYM[mux_stage3][14]
        localparam n = 4;
        logic [7:0] i;
        assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:5] ~GENSYM[res][7];
      ~GENERATE
      if (1) begin
      localparam n = 5;
      logic [9:0] i;
      assign i = ~SYM[12][0:9];
      always_comb begin
        case (i[n-1+n])
          1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
          default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
        endcase
      end
      end
      ~ENDGENERATE

      assign ~RESULT = $unsigned(~SYM[7]);
      // ctz32 end
- BlackBox:
    name: GHC.Prim.ctz64#
    imports:
    - ~INCLUDENAME[0].inc
    includes:
    - name: enc
      extension: inc
      template: |-
        function [1:0] ~INCLUDENAME[0];
          input [1:0] a;
          case (a)
            2'b00:   ~INCLUDENAME[0] = 2'b10;
            2'b01:   ~INCLUDENAME[0] = 2'b01;
            2'b10:   ~INCLUDENAME[0] = 2'b00;
            default: ~INCLUDENAME[0] = 2'b00;
          endcase
        endfunction
    kind: Declaration
    type: 'ctz64 :: Word#
      -> Word#'
    template: |-
      // ctz64 begin
      logic [0:63] ~GENSYM[v][1];
      genvar ~GENSYM[k][18];
      ~GENERATE
      for (~SYM[18]=0;~SYM[18]<64;~SYM[18]=~SYM[18]+1) begin : ~GENSYM[reverse][19]
        assign ~SYM[1][~SYM[18]] = ~VAR[][0][~SYM[18]];
      end
      ~ENDGENERATE

      logic [0:63] ~GENSYM[e][2];
      genvar ~GENSYM[i][3];
      ~GENERATE
      for (~SYM[3]=0;~SYM[3]<32;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
        assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
      end
      ~ENDGENERATE

      logic [0:47] ~GENSYM[a][4];
      genvar ~GENSYM[i1][5];
      ~GENERATE
      for (~SYM[5]=0;~SYM[5]<16;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
        localparam n = 2;
        logic [3:0] i;
        assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:31] ~GENSYM[b][9];
      genvar ~GENSYM[i2][10];
      ~GENERATE
      for (~SYM[10]=0;~SYM[10]<8;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
        localparam n = 3;
        logic [5:0] i;
        assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:19] ~GENSYM[c][12];
      genvar ~GENSYM[i3][13];
      ~GENERATE
      for (~SYM[13]=0;~SYM[13]<4;~SYM[13]=~SYM[13]+1) begin : ~GENSYM[mux_stage3][14]
        localparam n = 4;
        logic [7:0] i;
        assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:11] ~GENSYM[d][15];
      genvar ~GENSYM[i4][16];
      ~GENERATE
      for (~SYM[16]=0;~SYM[16]<2;~SYM[16]=~SYM[16]+1) begin : ~GENSYM[mux_stage4][17]
        localparam n = 5;
        logic [9:0] i;
        assign i = ~SYM[12][~SYM[16]*10:~SYM[16]*10+9];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:6] ~GENSYM[res][7];
      ~GENERATE
      if (1) begin
      localparam n = 6;
      logic [11:0] i;
      assign i = ~SYM[15][0:11];
      always_comb begin
        case (i[n-1+n])
          1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
          default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
        endcase
      end
      end
      ~ENDGENERATE

      assign ~RESULT = $unsigned(~SYM[7]);
      // ctz64 end
- BlackBox:
    name: GHC.Prim.ctz#
    imports:
    - ~INCLUDENAME[0].inc
    includes:
    - name: enc
      extension: inc
      template: |-
        function [1:0] ~INCLUDENAME[0];
          input [1:0] a;
          case (a)
            2'b00:   ~INCLUDENAME[0] = 2'b10;
            2'b01:   ~INCLUDENAME[0] = 2'b01;
            2'b10:   ~INCLUDENAME[0] = 2'b00;
            default: ~INCLUDENAME[0] = 2'b00;
          endcase
        endfunction
    kind: Declaration
    type: 'ctz :: Word# ->
      Word#'
    template: |-
      // ctz begin
      ~IF ~IW64 ~THEN
      logic [0:63] ~GENSYM[v][1];
      genvar ~GENSYM[k][18];
      ~GENERATE
      for (~SYM[18]=0;~SYM[18]<64;~SYM[18]=~SYM[18]+1) begin : ~GENSYM[reverse][19]
        assign ~SYM[1][~SYM[18]] = ~VAR[][0][~SYM[18]];
      end
      ~ENDGENERATE

      logic [0:63] ~GENSYM[e][2];
      genvar ~GENSYM[i][3];
      ~GENERATE
      for (~SYM[3]=0;~SYM[3]<32;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
        assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
      end
      ~ENDGENERATE

      logic [0:47] ~GENSYM[a][4];
      genvar ~GENSYM[i1][5];
      ~GENERATE
      for (~SYM[5]=0;~SYM[5]<16;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
        localparam n = 2;
        logic [3:0] i;
        assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:31] ~GENSYM[b][9];
      genvar ~GENSYM[i2][10];
      ~GENERATE
      for (~SYM[10]=0;~SYM[10]<8;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
        localparam n = 3;
        logic [5:0] i;
        assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:19] ~GENSYM[c][12];
      genvar ~GENSYM[i3][13];
      ~GENERATE
      for (~SYM[13]=0;~SYM[13]<4;~SYM[13]=~SYM[13]+1) begin : ~GENSYM[mux_stage3][14]
        localparam n = 4;
        logic [7:0] i;
        assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:11] ~GENSYM[d][15];
      genvar ~GENSYM[i4][16];
      ~GENERATE
      for (~SYM[16]=0;~SYM[16]<2;~SYM[16]=~SYM[16]+1) begin : ~GENSYM[mux_stage4][17]
        localparam n = 5;
        logic [9:0] i;
        assign i = ~SYM[12][~SYM[16]*10:~SYM[16]*10+9];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:6] ~GENSYM[res][7];
      ~GENERATE
      if (1) begin
      localparam n = 6;
      logic [11:0] i;
      assign i = ~SYM[15][0:11];
      always_comb begin
        case (i[n-1+n])
          1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
          default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
        endcase
      end
      end
      ~ENDGENERATE
      ~ELSE
      logic [0:31] ~SYM[1];
      genvar ~SYM[18];
      ~GENERATE
      for (~SYM[18]=0;~SYM[18]<32;~SYM[18]=~SYM[18]+1) begin : ~SYM[19]
        assign ~SYM[1][~SYM[18]] = ~VAR[][0][~SYM[18]];
      end
      ~ENDGENERATE

      logic [0:31] ~SYM[2];
      genvar ~SYM[3];
      ~GENERATE
      for (~SYM[3]=0;~SYM[3]<16;~SYM[3]=~SYM[3]+1) begin : ~SYM[8]
        assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
      end
      ~ENDGENERATE

      logic [0:23] ~SYM[4];
      genvar ~SYM[5];
      ~GENERATE
      for (~SYM[5]=0;~SYM[5]<8;~SYM[5]=~SYM[5]+1) begin : ~SYM[6]
        localparam n = 2;
        logic [3:0] i;
        assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:15] ~SYM[9];
      genvar ~SYM[10];
      ~GENERATE
      for (~SYM[10]=0;~SYM[10]<4;~SYM[10]=~SYM[10]+1) begin : ~SYM[11]
        localparam n = 3;
        logic [5:0] i;
        assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:9] ~SYM[12];
      genvar ~SYM[13];
      ~GENERATE
      for (~SYM[13]=0;~SYM[13]<2;~SYM[13]=~SYM[13]+1) begin : ~SYM[14]
        localparam n = 4;
        logic [7:0] i;
        assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
        always_comb begin
          case (i[n-1+n])
            1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
            default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
          endcase
        end
      end
      ~ENDGENERATE

      logic [0:5] ~SYM[7];
      ~GENERATE
      if (1) begin
      localparam n = 5;
      logic [9:0] i;
      assign i = ~SYM[12][0:9];
      always_comb begin
        case (i[n-1+n])
          1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
          default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
        endcase
      end
      end
      ~ENDGENERATE
      ~FI
      assign ~RESULT = $unsigned(~SYM[7]);
      // ctz end
- BlackBox:
    name: GHC.Prim.quotRemInt8#
    kind: Declaration
    type: 'quotRemInt8# ::
      Int8# -> Int8# -> (#Int8#, Int8##)'
    template: |-
      // quotRemInt8 begin
      ~SIGD[~GENSYM[quot_res][0]][0];
      ~SIGD[~GENSYM[rem_res][1]][0];
      assign ~SYM[0] = ~ARG[0] / ~ARG[1];
      assign ~SYM[1] = ~ARG[0] % ~ARG[1];

      assign ~RESULT = {~SYM[0],~SYM[1]};
      // quotRemInt8 end
- BlackBox:
    name: GHC.Prim.quotRemWord8#
    kind: Declaration
    type: 'quotRemWord8# ::
      Word8# -> Word8# -> (#Word8#, Word8##)'
    template: |-
      // quotRemWord8 begin
      ~SIGD[~GENSYM[quot_res][0]][0];
      ~SIGD[~GENSYM[rem_res][1]][0];
      assign ~SYM[0] = ~ARG[0] / ~ARG[1];
      assign ~SYM[1] = ~ARG[0] % ~ARG[1];

      assign ~RESULT = {~SYM[0],~SYM[1]};
      // quotRemWord8 end
- BlackBox:
    name: GHC.Prim.quotRemInt16#
    kind: Declaration
    type: 'quotRemInt16# ::
      Int16# -> Int16# -> (#Int16#, Int16##)'
    template: |-
      // quotRemInt16 begin
      ~SIGD[~GENSYM[quot_res][0]][0];
      ~SIGD[~GENSYM[rem_res][1]][0];
      assign ~SYM[0] = ~ARG[0] / ~ARG[1];
      assign ~SYM[1] = ~ARG[0] % ~ARG[1];

      assign ~RESULT = {~SYM[0],~SYM[1]};
      // quotRemInt16 end
- BlackBox:
    name: GHC.Prim.quotRemWord16#
    kind: Declaration
    type: 'quotRemWord16# ::
      Word16# -> Word16# -> (#Word16#, Word16##)'
    template: |-
      // quotRemWord16 begin
      ~SIGD[~GENSYM[quot_res][0]][0];
      ~SIGD[~GENSYM[rem_res][1]][0];
      assign ~SYM[0] = ~ARG[0] / ~ARG[1];
      assign ~SYM[1] = ~ARG[0] % ~ARG[1];

      assign ~RESULT = {~SYM[0],~SYM[1]};
      // quotRemWord16 end
- BlackBox:
    name: GHC.Prim.quotRemInt32#
    kind: Declaration
    type: 'quotRemInt32# ::
      Int32# -> Int32# -> (#Int32#, Int32##)'
    template: |-
      // quotRemInt32 begin
      ~SIGD[~GENSYM[quot_res][0]][0];
      ~SIGD[~GENSYM[rem_res][1]][0];
      assign ~SYM[0] = ~ARG[0] / ~ARG[1];
      assign ~SYM[1] = ~ARG[0] % ~ARG[1];

      assign ~RESULT = {~SYM[0],~SYM[1]};
      // quotRemInt32 end
- BlackBox:
    name: GHC.Prim.quotRemWord32#
    kind: Declaration
    type: 'quotRemWord32# ::
      Word32# -> Word32# -> (#Word32#, Word32##)'
    template: |-
      // quotRemWord32 begin
      ~SIGD[~GENSYM[quot_res][0]][0];
      ~SIGD[~GENSYM[rem_res][1]][0];
      assign ~SYM[0] = ~ARG[0] / ~ARG[1];
      assign ~SYM[1] = ~ARG[0] % ~ARG[1];

      assign ~RESULT = {~SYM[0],~SYM[1]};
      // quotRemWord32 end
